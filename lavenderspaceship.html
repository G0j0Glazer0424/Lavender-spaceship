<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Lavender Spaceship — Chill & Spacey Flappy</title>
<style>
  :root {
    --lav-100: #f7eefc;
    --lav-200: #e9ddfa;
    --lav-300: #d6c8f6;
    --lav-400: #bfa0f0;
    --lav-500: #9b78e8;
    --accent: #ffdeeb;
    --ground: #caa6e8;
    --pipe: #7b4bb0;
    --text: #2d0f3a;
    --star: #dcd6f7;
  }
  html, body {
    height: 100%;
    margin: 0;
    background: linear-gradient(180deg, var(--lav-100), var(--lav-300));
    font-family: 'Inter', system-ui, Segoe UI, Roboto, Helvetica Neue, Arial, sans-serif;
    overflow: hidden;
    color: var(--text);
  }
  #gameWrap {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    width: 100vw;
    max-width: 100vw;
    max-height: 100vh;
  }
  canvas {
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(80, 30, 120, 0.15);
    background: linear-gradient(180deg, var(--lav-200), var(--lav-400));
    display: block;
    width: 96vw;
    height: auto;
    max-width: 640px;
    max-height: 90vh;
    touch-action: none;
  }
  .hud {
    position: fixed;
    left: 20px;
    top: 20px;
    color: var(--text);
    user-select: none;
  }
  .btns {
    position: fixed;
    right: 20px;
    top: 20px;
  }
  button {
    background: var(--accent);
    border: 1px solid rgba(0, 0, 0, 0.06);
    padding: 8px 12px;
    border-radius: 8px;
    cursor: pointer;
    user-select: none;
    font-weight: 600;
  }
  .credits {
    position: fixed;
    left: 20px;
    bottom: 18px;
    color: rgba(45, 15, 58, 0.7);
    font-size: 13px;
    user-select: none;
  }
  #homeScreen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: linear-gradient(180deg, #5a3e9a, #2b1a5c);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    color: var(--accent);
    text-align: center;
    user-select: none;
    z-index: 10;
  }
  #homeScreen h1 {
    font-size: 48px;
    margin-bottom: 10px;
    text-shadow: 0 0 12px #bb99ffaa;
  }
  #homeScreen p {
    font-size: 20px;
    opacity: 0.85;
    margin-bottom: 30px;
  }
  #homeScreen small {
    font-size: 12px;
    opacity: 0.6;
  }
</style>
</head>
<body>
<div id="gameWrap">
  <canvas id="c" width="640" height="880"></canvas>
</div>
<div class="hud" id="hud"></div>
<div class="btns">
  <button id="mute">Mute</button>
  <button id="restart" disabled>Restart</button>
</div>
<div class="credits">Lavender Spaceship — Chill & Spacey • Spacebar / Click to fly</div>

<div id="deathScreen" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(44,20,60,0.92); z-index:20; color:#fff; display:flex; flex-direction:column; align-items:center; justify-content:center;">
  <h2 style="font-size:2.5em; margin-bottom:0.5em;">You Crashed!</h2>
  <div style="font-size:1.3em; margin-bottom:1.5em;">Score: <span id="deathScore">0</span> &nbsp;|&nbsp; Best: <span id="deathBest">0</span></div>
  <button id="toHomeBtn" style="padding:12px 28px; font-size:1.1em; border-radius:8px; border:none; background:#bfa0f0; color:#2d0f3a; font-weight:700; cursor:pointer;">Return to Home</button>
</div>


<div id="homeScreen">
  <h1>Lavender Spaceship</h1>
  <button id="selectShipBtn" style="padding:10px 24px; font-size:1em; border-radius:8px; border:none; background:#bfa0f0; color:#2d0f3a; font-weight:700; cursor:pointer; margin-bottom:14px;">Select Ship</button>
  <div id="shipSelectPanel" style="display:none; margin-bottom:18px; color:#fff; background:#7b4bb0; border-radius:10px; padding:18px 12px;">
    <div id="shipOptions" style="margin-bottom:10px;"></div>
    <button id="closeShipPanel" style="padding:6px 18px; border-radius:6px; border:none; background:#bfa0f0; color:#2d0f3a; font-weight:600; cursor:pointer;">Close</button>
  </div>
  <button id="startGameBtn" style="padding:14px 36px; font-size:1.2em; border-radius:8px; border:none; background:#bfa0f0; color:#2d0f3a; font-weight:700; cursor:pointer; margin-bottom:24px;">Start Game</button>
  <small>Use ↑ for stronger thrust, ↓ for soft thrust</small>
</div>

<script>
// --- Ship Skins ---
const SHIP_SKINS = [
  { name: "Classic", unlock: 0, colors: { shipPrimary: '#ccccff', shipAccent: '#88aaff', wing: '#9b78e8' } },
  { name: "Nebula", unlock: 50, colors: { shipPrimary: '#ffb3c6', shipAccent: '#ff8fab', wing: '#ff5eae' } },
  { name: "Emerald", unlock: 100, colors: { shipPrimary: '#baffc9', shipAccent: '#51e898', wing: '#2ec4b6' } },
  { name: "Solaris", unlock: 200, colors: { shipPrimary: '#ffe066', shipAccent: '#ffd166', wing: '#ff9f1c' } },
  // Planet-themed ships
  { name: "Swift Mercury", unlock: 250, colors: { shipPrimary: '#b0b0b0', shipAccent: '#e0e0e0', wing: '#8a8a8a' } },
  { name: "Venusian Aurora", unlock: 350, colors: { shipPrimary: '#f5deb3', shipAccent: '#ffe4b5', wing: '#e6c07b' } },
  { name: "Terra Voyager", unlock: 500, colors: { shipPrimary: '#4f9cff', shipAccent: '#7be495', wing: '#2d6a4f' } },
  { name: "Red Dune (Mars)", unlock: 590, colors: { shipPrimary: '#c1440e', shipAccent: '#ff6f3c', wing: '#a63a1b' } },
  { name: "Jovian Titan", unlock: 670, colors: { shipPrimary: '#f4e2d8', shipAccent: '#e3b778', wing: '#b97a56' } },
  { name: "Saturn Halo", unlock: 750, colors: { shipPrimary: '#f7e7b6', shipAccent: '#e6c07b', wing: '#bfa76f' } },
  { name: "Uranian Mist", unlock: 850, colors: { shipPrimary: '#b2f7ef', shipAccent: '#5dade2', wing: '#48b6a3' } },
  { name: "Neptune Wave", unlock: 911, colors: { shipPrimary: '#3a6ea5', shipAccent: '#5f8fd3', wing: '#274472' } },
  { name: "Pluto Phantom", unlock: 999, colors: { shipPrimary: '#e5e4e2', shipAccent: '#b0b0b0', wing: '#a89f91' } },
];
let selectedShipIndex = parseInt(localStorage.getItem('lavShipSelected')||'0',10) || 0;
let totalPipesCleared = parseInt(localStorage.getItem('lavTotalPipes')||'0',10) || 0;

function saveShipSelection(idx) {
  selectedShipIndex = idx;
  localStorage.setItem('lavShipSelected', idx);
}

function saveTotalPipes(count) {
  totalPipesCleared = count;
  localStorage.setItem('lavTotalPipes', count);
}

function getUnlockedShips() {
  return SHIP_SKINS.filter(s => totalPipesCleared >= s.unlock);
}

function showShipSelectPanel() {
  const panel = document.getElementById('shipSelectPanel');
  const options = document.getElementById('shipOptions');
  options.innerHTML = '';
  SHIP_SKINS.forEach((skin, idx) => {
    const unlocked = totalPipesCleared >= skin.unlock;
    const btn = document.createElement('button');
    btn.textContent = unlocked ? `${skin.name}${selectedShipIndex===idx?' ✓':''}` : `${skin.name} (Unlock at ${skin.unlock})`;
    btn.disabled = !unlocked;
    btn.style.margin = '0 8px 8px 0';
    btn.style.padding = '8px 16px';
    btn.style.borderRadius = '6px';
    btn.style.background = unlocked ? '#bfa0f0' : '#ccc';
    btn.style.color = '#2d0f3a';
    btn.style.fontWeight = unlocked ? '700' : '400';
    btn.onclick = () => {
      if (unlocked) {
        saveShipSelection(idx);
        showShipSelectPanel();
      }
    };
    options.appendChild(btn);
  });
  panel.style.display = 'block';
}

function hideShipSelectPanel() {
  document.getElementById('shipSelectPanel').style.display = 'none';
}

function getShipColors() {
  return { ...COLORS, ...SHIP_SKINS[selectedShipIndex].colors };
}
// Setup
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;

// Responsive resize
function resizeCanvas() {
  // Maintain aspect ratio (640x880)
  const aspect = 640/880;
  let ww = window.innerWidth * 0.98;
  let wh = window.innerHeight * 0.98;
  let cw = Math.min(ww, 640);
  let ch = Math.min(wh, 880);
  if (cw/ch > aspect) {
    cw = ch * aspect;
  } else {
    ch = cw / aspect;
  }
  canvas.style.width = cw + 'px';
  canvas.style.height = ch + 'px';
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();


let score = 0, best = parseInt(localStorage.getItem('lavSpaceshipBest')||'0',10) || 0;
let pipes = [];
let particles = [];
let gameOver = false;
let started = false;
let pause = false;
let mute = false;
let showingHomeScreen = false;

const COLORS = {
  bgTop: '#f7eefc',
  bgBottom: '#d6c8f6',
  pipe: '#7b4bb0',
  ground: '#caa6e8',
  shipPrimary: '#ccccff',
  shipAccent: '#88aaff',
  pipeAccent: '#6a3ea0',
  wing: '#9b78e8',
  eye: '#2d0f3a',
  star: '#dcd6f7',
  flame1: '#ffcc66',
  flame2: '#ffb833',
  flame3: '#ffaa00'
};

const GRAVITY = 1500;
const FLAP_POWER = -420;
const STRONG_FLAP_POWER = -520;
let pipeGapBase = 220;
let pipeSpeedBase = 220;
let pipeSpeed = pipeSpeedBase;
let spawnIntervalBase = 1.6;
let spawnTimer = 0;
let difficultyTimer = 0;

// Spaceship
const spaceship = {
  x: 160,
  y: H/2,
  vy: 0,
  width: 44,
  height: 40,
  rotation: 0,
  alive: true,
  wingPhase: 0,
  thrusting: 0, // 0 = no thrust, 1 = full thrust
};

// Stars for background animation
const stars = [];
for(let i=0; i<100; i++){
  stars.push({
    x: Math.random()*W,
    y: Math.random()*H,
    size: Math.random()*1.3 + 0.7,
    speed: Math.random()*20 + 10,
    twinklePhase: Math.random()*Math.PI*2
  });
}

// Audio
let audioCtx, masterGain;
let isAudioInit = false;

function initAudio(){
  if(isAudioInit) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = mute ? 0 : 0.12;
  masterGain.connect(audioCtx.destination);

  // Ambient pad synth (2 sine oscillators + slow LFO filter)
  const padFilter = audioCtx.createBiquadFilter();
  padFilter.type = 'lowpass';
  padFilter.frequency.value = 800;
  padFilter.connect(masterGain);

  const osc1 = audioCtx.createOscillator();
  osc1.type = 'sine'; osc1.frequency.value = 220;
  const osc2 = audioCtx.createOscillator();
  osc2.type = 'sine'; osc2.frequency.value = 330;
  const padGain = audioCtx.createGain();
  padGain.gain.value = 0.18;
  osc1.connect(padGain);
  osc2.connect(padGain);
  padGain.connect(padFilter);

  const lfo = audioCtx.createOscillator();
  lfo.frequency.value = 0.08;
  const lfoGain = audioCtx.createGain();
  lfoGain.gain.value = 400;
  lfo.connect(lfoGain);
  lfoGain.connect(padFilter.frequency);

  osc1.start(); osc2.start(); lfo.start();

  // Start melody loop
  scheduleMelodyLoop();

  isAudioInit = true;
}

let melodyInterval = 2.0; // seconds per phrase
function scheduleMelodyLoop(){
  if(!audioCtx || mute) return;
  const now = audioCtx.currentTime + 0.05;
  const notes = [440, 523.25, 659.25, 523.25]; // A4,C5,E5,C5
  const dur = melodyInterval / notes.length;
  notes.forEach((n,i)=>{
    const o = audioCtx.createOscillator();
    o.type = 'triangle';
    o.frequency.value = n;
    const g = audioCtx.createGain();
    g.gain.value = 0.0;
    o.connect(g); g.connect(masterGain);
    o.start(now + i*dur);
    g.gain.linearRampToValueAtTime(0.14, now + i*dur + 0.01);
    g.gain.linearRampToValueAtTime(0.0, now + (i+1)*dur - 0.02);
    o.stop(now + (i+1)*dur);
  });
  setTimeout(()=>{
    if(!mute) scheduleMelodyLoop();
  }, melodyInterval*1000);
}

function playFlapSound(){
  if(!audioCtx || mute) return;
  const now = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();
  osc.type = 'square';
  osc.frequency.setValueAtTime(880, now);
  osc.connect(gainNode);
  gainNode.connect(masterGain);
  gainNode.gain.setValueAtTime(0.0001, now);
  gainNode.gain.linearRampToValueAtTime(0.06, now + 0.005);
  gainNode.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);
  osc.start(now);
  osc.stop(now + 0.26);
}

function playCrashSound(){
  if(!audioCtx || mute) return;
  const now = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();
  osc.type = 'sawtooth';
  osc.frequency.setValueAtTime(100, now);
  osc.connect(gainNode);
  gainNode.connect(masterGain);
  gainNode.gain.setValueAtTime(0.2, now);
  gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
  osc.start(now);
  osc.stop(now + 0.5);
}

// Particle system for engine flame and explosion
function spawnParticle(x,y,vx,vy,life,color,size){
  particles.push({x,y,vx,vy,life,age:0,color,size});
}

// Reset game
function reset(){
  started = false;
  showingHomeScreen = false;
  document.getElementById('restart').disabled = true;
  document.getElementById('homeScreen').style.display = 'flex';
  document.getElementById('deathScreen').style.display = 'none'; // Hide death screen when showing home
  updateHUD();
}

// Rectangle collision check
function rectsOverlap(a,b){
  return !(a.x+a.w < b.x || a.x > b.x+b.w || a.y+a.h < b.y || a.y > b.y+b.h);
}

// Input handling
function flap(power){
  if(!spaceship.alive) return;
  spaceship.vy = power;
  // difficultyTimer = 0; // (optional: if you want to keep difficulty scaling on flap, leave this line, otherwise remove)
  // engine particles for spaceship (aligned with ship's rotation)
  const angle = spaceship.rotation;
  const flameBaseX = spaceship.x - Math.cos(angle) * 24;
  const flameBaseY = spaceship.y - Math.sin(angle) * 24;
  for(let i=0; i<6; i++) {
    // Add some random spread to the flame
    const spread = (Math.random() - 0.5) * 12;
    const px = flameBaseX + Math.sin(angle) * spread;
    const py = flameBaseY - Math.cos(angle) * spread;
    const vx = Math.cos(angle) * (-120 + Math.random()*60) + Math.random()*40-20;
    const vy = Math.sin(angle) * (-120 + Math.random()*60) + Math.random()*40-20;
    spawnParticle(px, py, vx, vy, 0.4+Math.random()*0.3, COLORS.flame2, 2+Math.random()*2);
  }
  // Set thrusting to max (1) for animation
  spaceship.thrusting = 1;
  playFlapSound();
}

window.addEventListener('keydown', e=>{
  const deathScreen = document.getElementById('deathScreen');
  const homeScreen = document.getElementById('homeScreen');
  // Prevent input if death screen or home screen is visible
  const deathVisible = deathScreen && deathScreen.style.display === 'flex';
  const homeVisible = homeScreen && homeScreen.style.display !== 'none';
  if (deathVisible || homeVisible) return;
  if (!spaceship.alive) return; // Block input if dead
  if(e.code === 'Space' || e.code === 'KeyW' || e.code === 'ArrowUp'){
    e.preventDefault();
    if(!started){
      startGame();
    }
    flap(e.code==='ArrowUp'||e.code==='KeyW' ? STRONG_FLAP_POWER : FLAP_POWER);
  }
  if(e.code === 'KeyS' || e.code === 'ArrowDown'){
    e.preventDefault();
    if(!started){
      startGame();
    }
    flap(FLAP_POWER*0.6);
  }
  if(e.code === 'KeyP'){
    pause = !pause;
  }
});

// Touch controls: tap = flap, double tap = strong flap
let lastTap = 0;
canvas.addEventListener('mousedown', e=>{
  const deathScreen = document.getElementById('deathScreen');
  if (deathScreen && deathScreen.style.display === 'flex') return;
  if (!spaceship.alive) return;
  if(!started) startGame();
  flap(FLAP_POWER);
});
canvas.addEventListener('touchstart', e=>{
  const deathScreen = document.getElementById('deathScreen');
  if (deathScreen && deathScreen.style.display === 'flex') return;
  if (!spaceship.alive) return;
  e.preventDefault();
  if(!started) startGame();
  let now = Date.now();
  if (now - lastTap < 350) {
    flap(STRONG_FLAP_POWER);
  } else {
    flap(FLAP_POWER);
  }
  lastTap = now;
});

document.getElementById('mute').addEventListener('click', ()=>{
  mute = !mute;
  if(masterGain) masterGain.gain.value = mute ? 0 : 0.12;
  document.getElementById('mute').textContent = mute ? 'Unmute' : 'Mute';
  if(!isAudioInit && !mute) initAudio();
});

document.getElementById('restart').addEventListener('click', ()=>{
  reset();
});

function startGame(){
  // Reset all game state here
  score = 0;
  pipes = [];
  particles = [];
  gameOver = false;
  started = true;
  spawnTimer = 0;
  difficultyTimer = 0;
  pipeGapBase = 220;
  pipeSpeed = pipeSpeedBase;
  spaceship.y = H/2;
  spaceship.vy = 0;
  spaceship.rotation = 0;
  spaceship.alive = true;
  showingHomeScreen = false;
  document.getElementById('restart').disabled = false;
  document.getElementById('homeScreen').style.display = 'none';
  updateHUD();
  if(!isAudioInit && !mute) initAudio();
  // Spawn the first pipe immediately
  const center = Math.random() * (H - 200 - pipeGapBase) + 120;
  pipes.push({
    x: W + 80,
    topH: center - pipeGapBase / 2,
    bottomY: center + pipeGapBase / 2,
    passed: false
  });
}

function updateHUD(){
  const hud = document.getElementById('hud');
  hud.textContent = 'Score: ' + score + '  Best: ' + best;
}

// Update game state
let lastTime = 0;
function update(ts){
  if(!lastTime) lastTime = ts;
  let dt = (ts - lastTime)/1000;
  if (dt > 0.04) dt = 0.04; // Clamp to ~25 FPS max step
  lastTime = ts;
  if(pause){
    draw();
    requestAnimationFrame(update);
    return;
  }
  if(!started){
    draw();
    requestAnimationFrame(update);
    return;
  }
  if(spaceship.alive){
    spaceship.vy += GRAVITY*dt;
    spaceship.y += spaceship.vy*dt;
    spaceship.rotation = Math.max(-0.6, Math.min(1.2, spaceship.vy/600));
    // Fade thrusting effect
    if (spaceship.thrusting > 0) {
      spaceship.thrusting -= dt * 2.5; // fade quickly
      if (spaceship.thrusting < 0) spaceship.thrusting = 0;
    }
  } else {
    // Death animation: spin and fall
    spaceship.vy += GRAVITY*dt;
    spaceship.y += spaceship.vy*dt;
    spaceship.rotation += 3 * dt; // spin faster
    if (spaceship.rotation > Math.PI * 2) spaceship.rotation -= Math.PI * 2;
  }
  spawnTimer += dt;
  difficultyTimer += dt;

  // Cap difficulty at level 10 (score 100)
  let level = Math.min(Math.floor(score/10), 10);
  let currentGap = pipeGapBase - level*10; // gap shrinks every 10 points (down to a min)
  if(currentGap < 140) currentGap = 140;
  let currentSpeed = pipeSpeedBase + level*40; // speed increases every 10 points
  let currentSpawnInterval = Math.max(0.8, spawnIntervalBase - level*0.15); // spawn interval decreases every 10 points, min 0.8s

  // Spawn pipes by timer (only if game is started and alive)
  if(started && spaceship.alive && spawnTimer > currentSpawnInterval){
    spawnTimer = 0;
    // Spawn pipe with current gap and speed modifiers
    const center = Math.random()*(H - 200 - currentGap) + 120;
    // After level 10 (score >= 100), pipes oscillate vertically
    if (level >= 10) {
      const oscPhase = Math.random() * Math.PI * 2;
      const oscSpeed = 1.2 + Math.random() * 0.8; // randomize speed a bit
      pipes.push({
        x: W + 80,
        topH: center - currentGap/2,
        bottomY: center + currentGap/2,
        passed: false,
        oscPhase,
        oscSpeed,
        baseCenter: center
      });
    } else {
      pipes.push({x: W + 80, topH: center - currentGap/2, bottomY: center + currentGap/2, passed:false});
    }
  }

  // Move pipes and check score
  for(let i = pipes.length-1; i >= 0; i--){
    let p = pipes[i];
    p.x -= currentSpeed * dt;
    // Oscillate pipes vertically if they have oscPhase (level >= 10)
    if (p.oscPhase !== undefined) {
      p.oscPhase += p.oscSpeed * dt;
      // Oscillate center position up and down by 80px
      const oscY = Math.sin(p.oscPhase) * 80;
      const center = p.baseCenter + oscY;
      p.topH = center - currentGap/2;
      p.bottomY = center + currentGap/2;
    }
    if(!p.passed && p.x + 40 < spaceship.x){
      p.passed = true;
      score++;
      saveTotalPipes(totalPipesCleared + 1);
      if(score > best){
        best = score;
        localStorage.setItem('lavSpaceshipBest', best);
      }
      updateHUD();
    }
    if(p.x < -120) pipes.splice(i,1);
  }

  // Collision detection
  const playerRect = {x: spaceship.x-22, y: spaceship.y-18, w:44, h:36};
  for(let p of pipes){
    let topRect = {x: p.x, y: 0, w: 72, h: p.topH};
    let bottomRect = {x: p.x, y: p.bottomY, w: 72, h: H - p.bottomY};
    if(rectsOverlap(playerRect, topRect) || rectsOverlap(playerRect, bottomRect)){
      if(spaceship.alive){
        spaceship.alive = false;
        gameOver = true;
        started = false;
        playCrashSound();
        for(let i=0; i<40; i++){
          spawnParticle(spaceship.x, spaceship.y, (Math.random()-0.5)*600, (Math.random()-0.5)*600, 0.8+Math.random()*0.6, COLORS.shipPrimary, 3+Math.random()*5);
        }
        if (!showingHomeScreen) {
          showingHomeScreen = true;
          setTimeout(() => {
            // Show death screen instead of home screen
            const deathScreen = document.getElementById('deathScreen');
            document.getElementById('deathScore').textContent = score;
            document.getElementById('deathBest').textContent = best;
            if (deathScreen) {
              deathScreen.style.display = 'flex';
            }
            showingHomeScreen = false;
          }, 1000); // 1 second delay for death animation
        }
      }
    }
  }

  // Ground & ceiling collision
  if(spaceship.y + 20 > H - 40){
    spaceship.y = H - 40 - 20;
    spaceship.vy = 0;
    if(spaceship.alive){
      spaceship.alive = false;
      gameOver = true;
      started = false;
      playCrashSound();
      for(let i=0; i<30; i++){
        spawnParticle(spaceship.x, spaceship.y, (Math.random()-0.5)*400, -Math.random()*300, 0.6+Math.random()*0.6, COLORS.ground, 4+Math.random()*4);
      }
      if (!showingHomeScreen) {
        showingHomeScreen = true;
        setTimeout(() => {
          // Show death screen instead of home screen
          const deathScreen = document.getElementById('deathScreen');
          document.getElementById('deathScore').textContent = score;
          document.getElementById('deathBest').textContent = best;
          if (deathScreen) {
            deathScreen.style.display = 'flex';
          }
          showingHomeScreen = false;
        }, 1000); // 1 second delay for death animation
      }
    }
  }
  if(spaceship.y - 20 < 0){
    spaceship.y = 20;
    spaceship.vy = 0;
  }

  // Update particles
  for(let i = particles.length-1; i >= 0; i--){
    let p = particles[i];
    p.age += dt;
    if(p.age > p.life){
      particles.splice(i,1);
      continue;
    }
    p.x += p.vx*dt;
    p.y += p.vy*dt;
    p.vy += 300*dt;
  }

  draw();
  requestAnimationFrame(update);
}

// Draw everything
function drawBackground(){
  // Gradient sky
  let g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0, COLORS.bgTop);
  g.addColorStop(1, COLORS.bgBottom);
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  // Stars (twinkle and drift slowly left/up)
  for(let star of stars){
    star.x -= star.speed * 0.015;
    star.y -= star.speed * 0.007;
    if(star.x < 0) star.x = W;
    if(star.y < 0) star.y = H;

    star.twinklePhase += 0.1;
    let alpha = 0.5 + Math.sin(star.twinklePhase) * 0.5;
    ctx.fillStyle = 'rgba(220,214,247,' + alpha.toFixed(2) + ')';
    ctx.beginPath();
    ctx.arc(star.x, star.y, star.size, 0, Math.PI*2);
    ctx.fill();
  }
}

function drawPipes(){
  ctx.fillStyle = COLORS.pipe;
  for(let p of pipes){
    // top pipe
    ctx.fillRect(p.x, 0, 72, p.topH);
    // bottom pipe
    ctx.fillRect(p.x, p.bottomY, 72, H - p.bottomY);

    // pipe accents
    ctx.fillStyle = COLORS.pipeAccent;
    ctx.fillRect(p.x + 2, p.topH - 14, 68, 14);
    ctx.fillRect(p.x + 2, p.bottomY, 68, 14);
    ctx.fillStyle = COLORS.pipe;
  }
}

function drawGround(){
  ctx.fillStyle = COLORS.ground;
  ctx.fillRect(0, H-40, W, 40);
}

function drawSpaceship(){
  const s = spaceship;
  const shipColors = getShipColors();
  ctx.save();
  ctx.translate(s.x, s.y);
  ctx.rotate(s.rotation);
  ctx.scale(1, 1);

  // Thrust flame (drawn behind body)
  if (s.thrusting > 0.05) {
    const flameLen = 28 + 18 * s.thrusting + Math.random()*6;
    const flameW = 10 + 8 * s.thrusting + Math.random()*3;
    ctx.save();
    ctx.globalAlpha = 0.55 * s.thrusting + 0.25 + Math.random()*0.1;
    ctx.beginPath();
    ctx.moveTo(-22, -6);
    ctx.lineTo(-22-flameLen, 0);
    ctx.lineTo(-22, 6);
    ctx.closePath();
    // Gradient for flame
    const grad = ctx.createLinearGradient(-22, 0, -22-flameLen, 0);
    grad.addColorStop(0, COLORS.flame2);
    grad.addColorStop(0.5, COLORS.flame1);
    grad.addColorStop(1, COLORS.flame3);
    ctx.fillStyle = grad;
    ctx.filter = 'blur(1.2px)';
    ctx.fill();
    ctx.filter = 'none';
    ctx.restore();
  }

  // Body
  ctx.fillStyle = shipColors.shipPrimary;
  ctx.beginPath();
  ctx.moveTo(-20, -10);
  ctx.lineTo(20, 0);
  ctx.lineTo(-20, 10);
  ctx.closePath();
  ctx.fill();

  // Wings (animated flapping)
  s.wingPhase += 0.3;
  const wingOffset = Math.sin(s.wingPhase)*6;
  ctx.fillStyle = shipColors.wing;
  ctx.beginPath();
  ctx.moveTo(-8, -10);
  ctx.lineTo(-8 + wingOffset, -22);
  ctx.lineTo(-2, -10);
  ctx.closePath();
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(-8, 10);
  ctx.lineTo(-8 + wingOffset, 22);
  ctx.lineTo(-2, 10);
  ctx.closePath();
  ctx.fill();

  // Window
  ctx.fillStyle = shipColors.shipAccent;
  ctx.beginPath();
  ctx.ellipse(5, 0, 8, 7, 0, 0, Math.PI*2);
  ctx.fill();

  // Eye
  ctx.fillStyle = COLORS.eye;
  ctx.beginPath();
  ctx.ellipse(10, 0, 2, 3, 0, 0, Math.PI*2);
  ctx.fill();

  // Engine flame particles (glow)
  for(let p of particles){
    if(p.color === COLORS.flame2){
      const alpha = 1 - (p.age / p.life);
      ctx.fillStyle = `rgba(255, 184, 51, ${alpha.toFixed(2)})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
      ctx.fill();
    }
  }

  ctx.restore();
}

function drawParticles(){
  for(let p of particles){
    if(p.color !== COLORS.flame2){
      const alpha = 1 - (p.age / p.life);
      ctx.fillStyle = p.color.startsWith('rgba') ? p.color : `rgba(155,120,232,${alpha.toFixed(2)})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
      ctx.fill();
    }
  }
}

function draw(){
  drawBackground();
  drawPipes();
  drawGround();
  drawSpaceship();
  drawParticles();
}
requestAnimationFrame(update);

reset();
// Show ship select panel if player unlocks a new ship after a run
if (getUnlockedShips().length > 1 && !localStorage.getItem('lavShipNotified')) {
  showShipSelectPanel();
  localStorage.setItem('lavShipNotified', '1');
}

// Death screen logic (always active, not just on DOMContentLoaded)
const deathScreen = document.getElementById('deathScreen');
const toHomeBtn = document.getElementById('toHomeBtn');
if (toHomeBtn) {
  toHomeBtn.addEventListener('click', () => {
    deathScreen.style.display = 'none';
    reset();
  });
}
// Also allow pressing Enter to return to home (but not Spacebar)
window.addEventListener('keydown', (e) => {
  if (deathScreen.style.display === 'flex' && e.code === 'Enter') {
    deathScreen.style.display = 'none';
    reset();
  }
});

// Home screen Start Game button interaction
const startGameBtn = document.getElementById('startGameBtn');
if (startGameBtn) {
  startGameBtn.addEventListener('click', () => {
    startGame();
  });
}
// Ship select button
const selectShipBtn = document.getElementById('selectShipBtn');
if (selectShipBtn) {
  selectShipBtn.addEventListener('click', () => {
    showShipSelectPanel();
  });
}
const closeShipPanel = document.getElementById('closeShipPanel');
if (closeShipPanel) {
  closeShipPanel.addEventListener('click', () => {
    hideShipSelectPanel();
  });
}
// Hide ship panel if clicking outside
document.addEventListener('mousedown', (e) => {
  const panel = document.getElementById('shipSelectPanel');
  if (panel && panel.style.display === 'block' && !panel.contains(e.target) && e.target.id !== 'selectShipBtn') {
    panel.style.display = 'none';
  }
});

// Prevent scrolling on touch devices when touching canvas
document.body.addEventListener('touchmove', e=>{
  if(e.target === canvas){
    e.preventDefault();
  }
},{ passive: false });

// Accessibility: show instructions if muted
if(mute){
  alert('Game is muted. Click Unmute to hear chill spacey music.');
}

</script>
</body>
</html>
